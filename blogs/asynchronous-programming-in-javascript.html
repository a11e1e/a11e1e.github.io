<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Javascript 中的异步编程 | 刘理铖</title>
    <meta name="description" content="Javascript 中的异步编程令我感到困惑。所以我决定按时间线重新梳理异步编程的解决方案。知其然，知其所以然。">
    <link rel="stylesheet" href="/assets/style.5ea99ec0.css">
    <link rel="modulepreload" href="/assets/Home.fead568d.js">
    <link rel="modulepreload" href="/assets/app.20f8a02e.js">
    <link rel="modulepreload" href="/assets/blogs_asynchronous-programming-in-javascript.md.3ba5dedd.lean.js">
    <link rel="modulepreload" href="/assets/app.20f8a02e.js">
    <meta name="twitter:title" content="Javascript 中的异步编程 | 刘理铖">
    <meta property="og:title" content="Javascript 中的异步编程 | 刘理铖">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme"><header class="nav-bar" data-v-675d8756><div class="sidebar-button" data-v-675d8756><svg class="icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z" class></path></svg></div><a class="nav-bar-title" href="/" aria-label="刘理铖, back to home" data-v-675d8756 data-v-4a583abe><!----> 刘理铖</a><div class="flex-grow" data-v-675d8756></div><div class="nav" data-v-675d8756><nav class="nav-links" data-v-675d8756 data-v-eab3edfe><!--[--><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/" data-v-b8818f8c>首页 <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item active" href="/blogs/" data-v-b8818f8c>博客 <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/about/" data-v-b8818f8c>关于 <!----></a></div></div><!--]--><!----><!----></nav></div><!--[--><!--]--></header><aside class="sidebar" data-v-83e92a68><nav class="nav-links nav" data-v-83e92a68 data-v-eab3edfe><!--[--><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/" data-v-b8818f8c>首页 <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item active" href="/blogs/" data-v-b8818f8c>博客 <!----></a></div></div><div class="item" data-v-eab3edfe><div class="nav-link" data-v-eab3edfe data-v-b8818f8c><a class="item" href="/about/" data-v-b8818f8c>关于 <!----></a></div></div><!--]--><!----><!----></nav><!--[--><!--]--><ul class="sidebar-links" data-v-83e92a68><!--[--><li class="sidebar-link"><a class="sidebar-link-item" href="#什么是异步？">什么是异步？</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#先理解什么是同步">先理解什么是同步</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#为什么需要异步？">为什么需要异步？</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#曾经我们如何解决异步">曾经我们如何解决异步</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#回调函数">回调函数</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#回调函数的问题">回调函数的问题</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#promise">Promise</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#生产者代码">生产者代码</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#消费者代码">消费者代码</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#promise-链">Promise 链</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#思考题">思考题</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#promise-api">Promise API</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#async-await">async / await</a><ul class="sidebar-links"><li class="sidebar-link"><a class="sidebar-link-item" href="#async-function">Async function</a><!----></li><li class="sidebar-link"><a class="sidebar-link-item" href="#await">Await</a><!----></li></ul></li><li class="sidebar-link"><a class="sidebar-link-item" href="#参考阅读">参考阅读</a><!----></li><!--]--></ul><!--[--><!--]--></aside><!-- TODO: make this button accessible --><div class="sidebar-mask"></div><main class="page" data-v-7eddb2c4><div class="container" data-v-7eddb2c4><!--[--><!--]--><div style="position:relative;" class="content" data-v-7eddb2c4><div><h2 id="什么是异步？" tabindex="-1">什么是异步？ <a class="header-anchor" href="#什么是异步？" aria-hidden="true">#</a></h2><h3 id="先理解什么是同步" tabindex="-1">先理解什么是同步 <a class="header-anchor" href="#先理解什么是同步" aria-hidden="true">#</a></h3><p>要理解异步，就先明白什么是同步。同步其实很符合人的常识。代码按顺序从上到下执行。</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 第一个被调用的函数</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">second</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 第二个被调用的函数</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">third</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 第三个被调用的函数</span>
<span class="token punctuation">}</span>

<span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">second</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">third</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>按照常识，只有<code>first</code><strong>执行完毕</strong>之后，<code>second</code>才会开始运行，只有<code>second</code><strong>执行完毕</strong>之后，<code>third</code>才会开始运行。</p><h3 id="为什么需要异步？" tabindex="-1">为什么需要异步？ <a class="header-anchor" href="#为什么需要异步？" aria-hidden="true">#</a></h3><p>假设一个新的场景：</p><ul><li><code>first</code>非常耗时，但又不占据 CPU，比如网络请求。</li><li><code>second</code>依赖<code>first</code>的运行结果。</li><li><code>third</code>随时可以运行。</li></ul><p>如果依然使用同步模式，就会造成这样一个问题——<code>third</code>只有在<code>first</code>和<code>second</code>执行完毕之后才可以开始执行。而<code>third</code>其实在<code>first</code>执行过程中就可以开始执行了。</p><p>这种情况在浏览器端比比皆是。</p><h2 id="曾经我们如何解决异步" tabindex="-1">曾经我们如何解决异步 <a class="header-anchor" href="#曾经我们如何解决异步" aria-hidden="true">#</a></h2><h3 id="回调函数" tabindex="-1">回调函数 <a class="header-anchor" href="#回调函数" aria-hidden="true">#</a></h3><p>举个例子：</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;You clicked me!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
btn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;click&quot;</span><span class="token punctuation">,</span> handleClick<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>函数<code>handleClick</code>就是一个回调函数。在这个例子中，回调函数<code>handleClick</code>作为一个参数，传递给另一个函数<code>addEventListener</code>,含义是「在<code>click</code>事件发生后调用<code>handleClick</code>函数」。</p><p>广义地说，回调函数（<code>handleClick</code>）的作用就是通知那个包含回调函数的函数（<code>addEventListener</code>），在合适的时机（<code>click</code>事件发生后）调用我。</p><p>所以，在上一章中，可以用回调函数的方式来解决新场景的问题，譬如。</p><div class="language-js"><pre><code><span class="token comment">// todo: onFinish的实现</span>

first<span class="token punctuation">.</span>onFinish <span class="token operator">=</span> f2<span class="token punctuation">;</span>
</code></pre></div><h3 id="回调函数的问题" tabindex="-1">回调函数的问题 <a class="header-anchor" href="#回调函数的问题" aria-hidden="true">#</a></h3><p>如果我们想在回调函数中执行回调函数怎么办？</p><p>如果我们想在回调函数中执行包含回调函数的回调函数怎么办？</p><div class="language-js"><pre><code><span class="token function">loadScript</span><span class="token punctuation">(</span><span class="token string">&quot;1.js&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">,</span> script</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">handleError</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token function">loadScript</span><span class="token punctuation">(</span><span class="token string">&quot;2.js&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">,</span> script</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">handleError</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">// ...</span>
        <span class="token function">loadScript</span><span class="token punctuation">(</span><span class="token string">&quot;3.js&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">,</span> script</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">handleError</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// ...加载完所有脚本后继续 (*)</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>看看这种代码，我不是很希望遇见这种代码。</p><h2 id="promise" tabindex="-1">Promise <a class="header-anchor" href="#promise" aria-hidden="true">#</a></h2><p>稍微现代一些的异步解决方案是使用<code>Promise</code>。</p><h3 id="生产者代码" tabindex="-1">生产者代码 <a class="header-anchor" href="#生产者代码" aria-hidden="true">#</a></h3><p><code>Promise</code>是一个特殊的类。它的构造器（constructor）语法如下：</p><div class="language-js"><pre><code><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 做一些事情</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>传递给 new Promise 的函数被称为 <strong>executor</strong>。当 <code>new Promise</code> 被创建，executor 会自动运行。</p><p>它的参数 <code>resolve</code> 和 <code>reject</code> 是由 JavaScript 自身提供的回调。我们需要遵循的原则是：</p><ul><li>如果<strong>executor</strong>顺利执行，应该调用<code>resolve(value)</code></li><li>如果不顺利，应该调用<code>resolve(value)</code></li></ul><p>由 <code>new Promise</code> 构造器返回的 <code>promise</code> 对象具有以下内部属性：</p><ul><li><code>state</code> — 最初是 <code>&quot;pending&quot;</code>，然后在 <code>resolve</code> 被调用时变为 <code>&quot;fulfilled&quot;</code>，或者在 <code>reject</code> 被调用时变为 <code>&quot;rejected&quot;</code>。</li><li><code>result</code> — 最初是 <code>undefined</code>，然后在 <code>resolve(value)</code> 被调用时变为 <code>value</code>，或者在 <code>reject(error)</code> 被调用时变为 <code>error</code>。</li></ul><p>总而言之，<code>executor</code> 应该执行一项工作（通常是需要花费一些时间的事儿），然后调用 <code>resolve</code> 或 <code>reject</code> 来改变对应的 <code>promise</code> 对象的状态。</p><p><code>executor</code> 里的代码可以被称为<strong>生产者代码</strong>。</p><h3 id="消费者代码" tabindex="-1">消费者代码 <a class="header-anchor" href="#消费者代码" aria-hidden="true">#</a></h3><h4 id="then" tabindex="-1">then <a class="header-anchor" href="#then" aria-hidden="true">#</a></h4><p>最重要最基础的一个就是 <code>.then</code>。</p><p>语法如下：</p><div class="language-js"><pre><code>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
  <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* handle a successful result */</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* handle an error */</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><code>.then</code> 的第一个参数是一个函数，该函数将在 promise <code>resolved</code> 后运行并接收 <code>result</code>。</p><p><code>.then</code> 的第二个参数也是一个函数，该函数将在 promise <code>rejected</code> 后运行并接收 <code>error</code>。</p><h4 id="catch" tabindex="-1">catch <a class="header-anchor" href="#catch" aria-hidden="true">#</a></h4><p>等价于<code>.then(null, errorHandlingFunction)</code></p><p>如果发生了错误也没有被处理，会产生一个全局错误。</p><h4 id="finally" tabindex="-1">finally <a class="header-anchor" href="#finally" aria-hidden="true">#</a></h4><p><code>.finally(f)</code> 与 <code>.then(f, f)</code> 类似。<code>f</code> 总是在 promise 被 <code>settled</code> 时运行。</p><p>区别在于：</p><ul><li><code>finally</code> 里的函数没有参数。因为我们不知道 promise 成功与否。</li><li><code>finally</code> 处理程序将 <code>result</code> 和 <code>error</code> 传递给下一个处理程序。</li></ul><h3 id="promise-链" tabindex="-1">Promise 链 <a class="header-anchor" href="#promise-链" aria-hidden="true">#</a></h3><p>Promise 链看起来就像这样：</p><div class="language-js"><pre><code><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// (*)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// (**)</span>

    <span class="token function">alert</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
    <span class="token keyword">return</span> result <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// (***)</span>

    <span class="token function">alert</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>
    <span class="token keyword">return</span> result <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">alert</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 4</span>
    <span class="token keyword">return</span> result <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>为什么可以这样？因为对 <code>promise.then</code> 的调用会返回了一个 <code>promise</code>，所以我们可以在其之上调用下一个 <code>.then</code>。</p><p>还有一种容易搞混的情况：</p><div class="language-js"><pre><code><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
  <span class="token keyword">return</span> result <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
  <span class="token keyword">return</span> result <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">alert</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>
  <span class="token keyword">return</span> result <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>它们不会相互传递 result；相反，它们之间彼此独立运行处理任务。</p><h3 id="思考题" tabindex="-1">思考题 <a class="header-anchor" href="#思考题" aria-hidden="true">#</a></h3><div class="language-js"><pre><code><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Whoops!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span>alert<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>问：<code>.catch</code> 会被触发么？</p><p><a href="https://zh.javascript.info/promise-error-handling#tasks" target="_blank" rel="noopener noreferrer">答案在这</a>。</p><h3 id="promise-api" tabindex="-1">Promise API <a class="header-anchor" href="#promise-api" aria-hidden="true">#</a></h3><p>Promise 类有 5 种静态方法：</p><ul><li><code>Promise.all(promises)</code> —— 等待所有 promise 都 <code>resolve</code> 时，返回存放它们结果的数组。如果给定的任意一个 promise 为 <code>reject</code>，那么它就会变成 <code>Promise.all</code> 的 <code>error</code>，所有其他 promise 的结果都会被忽略。</li><li><code>Promise.allSettled(promises)</code>（ES2020 新增方法）—— 等待所有 promise 都 settle 时，并以包含以下内容的对象数组的形式返回它们的结果： <ul><li><code>status</code>: <code>&quot;fulfilled&quot;</code> 或 <code>&quot;rejected&quot;</code></li><li><code>value</code>（如果 <code>fulfilled</code>）或 <code>reason</code>（如果 <code>rejected</code>）。</li></ul></li><li><code>Promise.race(promises)</code> —— 等待第一个 settle 的 <code>promise</code>，并将其 result/error 作为结果。</li><li><code>Promise.resolve(value)</code> —— 使用给定 <code>value</code> 创建一个 <code>resolved</code> 的 promise。</li><li><code>Promise.reject(error)</code> —— 使用给定 <code>error</code> 创建一个 <code>rejected</code> 的 promise。</li></ul><h2 id="async-await" tabindex="-1">async / await <a class="header-anchor" href="#async-await" aria-hidden="true">#</a></h2><p>Async/await 是以更舒适的方式使用 promise 的一种特殊语法，同时它也非常易于理解和使用。</p><h3 id="async-function" tabindex="-1">Async function <a class="header-anchor" href="#async-function" aria-hidden="true">#</a></h3><p><code>async</code> 关键字可以被放置在一个函数前面，如下所示：</p><div class="language-js"><pre><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在函数前面的 “async” 这个单词表达了一个简单的事情：即这个函数总是返回一个 promise。其他值将自动被包装在一个 resolved 的 promise 中。</p><div class="language-js"><pre><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>alert<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>alert<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// f1与f2等价</span>
</code></pre></div><h3 id="await" tabindex="-1">Await <a class="header-anchor" href="#await" aria-hidden="true">#</a></h3><div class="language-js"><pre><code><span class="token comment">// 只在 async 函数内工作</span>
<span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">await</span> promise<span class="token punctuation">;</span>
</code></pre></div><p>关键字 <code>await</code> 让 JavaScript 引擎等待直到 promise 完成（settle）并返回结果。这个行为不会耗费任何 CPU 资源，因为 JavaScript 引擎可以同时处理其他任务：执行其他脚本，处理事件等。</p><h2 id="参考阅读" tabindex="-1">参考阅读 <a class="header-anchor" href="#参考阅读" aria-hidden="true">#</a></h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous" target="_blank" rel="noopener noreferrer">异步 JavaScript</a></li><li><a href="https://zh.javascript.info/async" target="_blank" rel="noopener noreferrer">JavaScript 编程语言 - Promise，async/await</a></li><li><a href="https://www.ruanyifeng.com/blog/2015/04/generator.html" target="_blank" rel="noopener noreferrer">《深入掌握 ECMAScript 6 异步编程》</a></li></ul></div></div><footer class="page-footer" data-v-7eddb2c4 data-v-fb8d84c6><div class="edit" data-v-fb8d84c6><div class="edit-link" data-v-fb8d84c6 data-v-1ed99556><!----></div></div><div class="updated" data-v-fb8d84c6><!----></div></footer><!----><!--[--><!--]--></div></main></div><!----><!--]--></div>
    <script>__VP_HASH_MAP__ = JSON.parse("{\"about_index.md\":\"1cf178f8\",\"blogs_asynchronous-programming-in-javascript.md\":\"3ba5dedd\",\"blogs_index.md\":\"4537733a\",\"blogs_javascript-modularity.md\":\"262c47d9\",\"index.md\":\"f476c3cf\"}")</script>
    <script type="module" async src="/assets/app.20f8a02e.js"></script>
    
  </body>
</html>