import{_ as n,c as s,o as a,d as t}from"./app.331ecafa.js";const p='{"title":"Javascript 中的异步编程","description":"Javascript 中的异步编程令我感到困惑。所以我决定按时间线重新梳理异步编程的解决方案。知其然，知其所以然。","frontmatter":{"date":"2021-10-16T00:00:00.000Z","title":"Javascript 中的异步编程","description":"Javascript 中的异步编程令我感到困惑。所以我决定按时间线重新梳理异步编程的解决方案。知其然，知其所以然。"},"headers":[{"level":2,"title":"什么是异步？","slug":"什么是异步？"},{"level":3,"title":"先理解什么是同步","slug":"先理解什么是同步"},{"level":3,"title":"为什么需要异步？","slug":"为什么需要异步？"},{"level":2,"title":"曾经我们如何解决异步","slug":"曾经我们如何解决异步"},{"level":3,"title":"回调函数","slug":"回调函数"},{"level":3,"title":"回调函数的问题","slug":"回调函数的问题"},{"level":2,"title":"Promise","slug":"promise"},{"level":3,"title":"生产者代码","slug":"生产者代码"},{"level":3,"title":"消费者代码","slug":"消费者代码"},{"level":3,"title":"Promise 链","slug":"promise-链"},{"level":3,"title":"思考题","slug":"思考题"},{"level":3,"title":"Promise API","slug":"promise-api"},{"level":2,"title":"async / await","slug":"async-await"},{"level":3,"title":"Async function","slug":"async-function"},{"level":3,"title":"Await","slug":"await"},{"level":2,"title":"参考阅读","slug":"参考阅读"}],"relativePath":"blogs/asynchronous-programming-in-javascript.md","lastUpdated":1634635980208}',e={},o=[t('<h1 id="javascript-中的异步编程" tabindex="-1">Javascript 中的异步编程 <a class="header-anchor" href="#javascript-中的异步编程" aria-hidden="true">#</a></h1><h2 id="什么是异步？" tabindex="-1">什么是异步？ <a class="header-anchor" href="#什么是异步？" aria-hidden="true">#</a></h2><h3 id="先理解什么是同步" tabindex="-1">先理解什么是同步 <a class="header-anchor" href="#先理解什么是同步" aria-hidden="true">#</a></h3><p>要理解异步，就先明白什么是同步。同步其实很符合人的常识。代码按顺序从上到下执行。</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 第一个被调用的函数</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">second</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 第二个被调用的函数</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">function</span> <span class="token function">third</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 第三个被调用的函数</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token function">second</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token function">third</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div><p>按照常识，只有<code>first</code><strong>执行完毕</strong>之后，<code>second</code>才会开始运行，只有<code>second</code><strong>执行完毕</strong>之后，<code>third</code>才会开始运行。</p><h3 id="为什么需要异步？" tabindex="-1">为什么需要异步？ <a class="header-anchor" href="#为什么需要异步？" aria-hidden="true">#</a></h3><p>假设一个新的场景：</p><ul><li><code>first</code>非常耗时，但又不占据 CPU，比如网络请求。</li><li><code>second</code>依赖<code>first</code>的运行结果。</li><li><code>third</code>随时可以运行。</li></ul><p>如果依然使用同步模式，就会造成这样一个问题——<code>third</code>只有在<code>first</code>和<code>second</code>执行完毕之后才可以开始执行。而<code>third</code>其实在<code>first</code>执行过程中就可以开始执行了。</p><p>这种情况在浏览器端比比皆是。</p><h2 id="曾经我们如何解决异步" tabindex="-1">曾经我们如何解决异步 <a class="header-anchor" href="#曾经我们如何解决异步" aria-hidden="true">#</a></h2><h3 id="回调函数" tabindex="-1">回调函数 <a class="header-anchor" href="#回调函数" aria-hidden="true">#</a></h3><p>举个例子：</p><div class="language-js"><pre><code><span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">alert</span><span class="token punctuation">(</span><span class="token string">&quot;You clicked me!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\nbtn<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">&quot;click&quot;</span><span class="token punctuation">,</span> handleClick<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div><p>函数<code>handleClick</code>就是一个回调函数。在这个例子中，回调函数<code>handleClick</code>作为一个参数，传递给另一个函数<code>addEventListener</code>,含义是「在<code>click</code>事件发生后调用<code>handleClick</code>函数」。</p><p>广义地说，回调函数（<code>handleClick</code>）的作用就是通知那个包含回调函数的函数（<code>addEventListener</code>），在合适的时机（<code>click</code>事件发生后）调用我。</p><p>所以，在上一章中，可以用回调函数的方式来解决新场景的问题，譬如。</p><div class="language-js"><pre><code><span class="token comment">// todo: onFinish的实现</span>\n\nfirst<span class="token punctuation">.</span>onFinish <span class="token operator">=</span> f2<span class="token punctuation">;</span>\n</code></pre></div><h3 id="回调函数的问题" tabindex="-1">回调函数的问题 <a class="header-anchor" href="#回调函数的问题" aria-hidden="true">#</a></h3><p>如果我们想在回调函数中执行回调函数怎么办？</p><p>如果我们想在回调函数中执行包含回调函数的回调函数怎么办？</p><div class="language-js"><pre><code><span class="token function">loadScript</span><span class="token punctuation">(</span><span class="token string">&quot;1.js&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">,</span> script</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">handleError</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n    <span class="token comment">// ...</span>\n    <span class="token function">loadScript</span><span class="token punctuation">(</span><span class="token string">&quot;2.js&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">,</span> script</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">handleError</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n        <span class="token comment">// ...</span>\n        <span class="token function">loadScript</span><span class="token punctuation">(</span><span class="token string">&quot;3.js&quot;</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">,</span> script</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token keyword">if</span> <span class="token punctuation">(</span>error<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token function">handleError</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>\n          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n            <span class="token comment">// ...加载完所有脚本后继续 (*)</span>\n          <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div><p>看看这种代码，我不是很希望遇见这种代码。</p><h2 id="promise" tabindex="-1">Promise <a class="header-anchor" href="#promise" aria-hidden="true">#</a></h2><p>稍微现代一些的异步解决方案是使用<code>Promise</code>。</p><h3 id="生产者代码" tabindex="-1">生产者代码 <a class="header-anchor" href="#生产者代码" aria-hidden="true">#</a></h3><p><code>Promise</code>是一个特殊的类。它的构造器（constructor）语法如下：</p><div class="language-js"><pre><code><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 做一些事情</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div><p>传递给 new Promise 的函数被称为 <strong>executor</strong>。当 <code>new Promise</code> 被创建，executor 会自动运行。</p><p>它的参数 <code>resolve</code> 和 <code>reject</code> 是由 JavaScript 自身提供的回调。我们需要遵循的原则是：</p><ul><li>如果<strong>executor</strong>顺利执行，应该调用<code>resolve(value)</code></li><li>如果不顺利，应该调用<code>resolve(value)</code></li></ul><p>由 <code>new Promise</code> 构造器返回的 <code>promise</code> 对象具有以下内部属性：</p><ul><li><code>state</code> — 最初是 <code>&quot;pending&quot;</code>，然后在 <code>resolve</code> 被调用时变为 <code>&quot;fulfilled&quot;</code>，或者在 <code>reject</code> 被调用时变为 <code>&quot;rejected&quot;</code>。</li><li><code>result</code> — 最初是 <code>undefined</code>，然后在 <code>resolve(value)</code> 被调用时变为 <code>value</code>，或者在 <code>reject(error)</code> 被调用时变为 <code>error</code>。</li></ul><p>总而言之，<code>executor</code> 应该执行一项工作（通常是需要花费一些时间的事儿），然后调用 <code>resolve</code> 或 <code>reject</code> 来改变对应的 <code>promise</code> 对象的状态。</p><p><code>executor</code> 里的代码可以被称为<strong>生产者代码</strong>。</p><h3 id="消费者代码" tabindex="-1">消费者代码 <a class="header-anchor" href="#消费者代码" aria-hidden="true">#</a></h3><h4 id="then" tabindex="-1">then <a class="header-anchor" href="#then" aria-hidden="true">#</a></h4><p>最重要最基础的一个就是 <code>.then</code>。</p><p>语法如下：</p><div class="language-js"><pre><code>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>\n  <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">/* handle a successful result */</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">/* handle an error */</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div><p><code>.then</code> 的第一个参数是一个函数，该函数将在 promise <code>resolved</code> 后运行并接收 <code>result</code>。</p><p><code>.then</code> 的第二个参数也是一个函数，该函数将在 promise <code>rejected</code> 后运行并接收 <code>error</code>。</p><h4 id="catch" tabindex="-1">catch <a class="header-anchor" href="#catch" aria-hidden="true">#</a></h4><p>等价于<code>.then(null, errorHandlingFunction)</code></p><p>如果发生了错误也没有被处理，会产生一个全局错误。</p><h4 id="finally" tabindex="-1">finally <a class="header-anchor" href="#finally" aria-hidden="true">#</a></h4><p><code>.finally(f)</code> 与 <code>.then(f, f)</code> 类似。<code>f</code> 总是在 promise 被 <code>settled</code> 时运行。</p><p>区别在于：</p><ul><li><code>finally</code> 里的函数没有参数。因为我们不知道 promise 成功与否。</li><li><code>finally</code> 处理程序将 <code>result</code> 和 <code>error</code> 传递给下一个处理程序。</li></ul><h3 id="promise-链" tabindex="-1">Promise 链 <a class="header-anchor" href="#promise-链" aria-hidden="true">#</a></h3><p>Promise 链看起来就像这样：</p><div class="language-js"><pre><code><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// (*)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// (**)</span>\n\n    <span class="token function">alert</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>\n    <span class="token keyword">return</span> result <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// (***)</span>\n\n    <span class="token function">alert</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2</span>\n    <span class="token keyword">return</span> result <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">alert</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 4</span>\n    <span class="token keyword">return</span> result <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div><p>为什么可以这样？因为对 <code>promise.then</code> 的调用会返回了一个 <code>promise</code>，所以我们可以在其之上调用下一个 <code>.then</code>。</p><p>还有一种容易搞混的情况：</p><div class="language-js"><pre><code><span class="token keyword">let</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\npromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">alert</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>\n  <span class="token keyword">return</span> result <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\npromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">alert</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>\n  <span class="token keyword">return</span> result <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\npromise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">alert</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>\n  <span class="token keyword">return</span> result <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div><p>它们不会相互传递 result；相反，它们之间彼此独立运行处理任务。</p><h3 id="思考题" tabindex="-1">思考题 <a class="header-anchor" href="#思考题" aria-hidden="true">#</a></h3><div class="language-js"><pre><code><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">&quot;Whoops!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span>alert<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre></div><p>问：<code>.catch</code> 会被触发么？</p><p><a href="https://zh.javascript.info/promise-error-handling#tasks" target="_blank" rel="noopener noreferrer">答案在这</a>。</p><h3 id="promise-api" tabindex="-1">Promise API <a class="header-anchor" href="#promise-api" aria-hidden="true">#</a></h3><p>Promise 类有 5 种静态方法：</p><ul><li><code>Promise.all(promises)</code> —— 等待所有 promise 都 <code>resolve</code> 时，返回存放它们结果的数组。如果给定的任意一个 promise 为 <code>reject</code>，那么它就会变成 <code>Promise.all</code> 的 <code>error</code>，所有其他 promise 的结果都会被忽略。</li><li><code>Promise.allSettled(promises)</code>（ES2020 新增方法）—— 等待所有 promise 都 settle 时，并以包含以下内容的对象数组的形式返回它们的结果： <ul><li><code>status</code>: <code>&quot;fulfilled&quot;</code> 或 <code>&quot;rejected&quot;</code></li><li><code>value</code>（如果 <code>fulfilled</code>）或 <code>reason</code>（如果 <code>rejected</code>）。</li></ul></li><li><code>Promise.race(promises)</code> —— 等待第一个 settle 的 <code>promise</code>，并将其 result/error 作为结果。</li><li><code>Promise.resolve(value)</code> —— 使用给定 <code>value</code> 创建一个 <code>resolved</code> 的 promise。</li><li><code>Promise.reject(error)</code> —— 使用给定 <code>error</code> 创建一个 <code>rejected</code> 的 promise。</li></ul><h2 id="async-await" tabindex="-1">async / await <a class="header-anchor" href="#async-await" aria-hidden="true">#</a></h2><p>Async/await 是以更舒适的方式使用 promise 的一种特殊语法，同时它也非常易于理解和使用。</p><h3 id="async-function" tabindex="-1">Async function <a class="header-anchor" href="#async-function" aria-hidden="true">#</a></h3><p><code>async</code> 关键字可以被放置在一个函数前面，如下所示：</p><div class="language-js"><pre><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre></div><p>在函数前面的 “async” 这个单词表达了一个简单的事情：即这个函数总是返回一个 promise。其他值将自动被包装在一个 resolved 的 promise 中。</p><div class="language-js"><pre><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">f1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>alert<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1</span>\n\n<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">f2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>alert<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// f1与f2等价</span>\n</code></pre></div><h3 id="await" tabindex="-1">Await <a class="header-anchor" href="#await" aria-hidden="true">#</a></h3><div class="language-js"><pre><code><span class="token comment">// 只在 async 函数内工作</span>\n<span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token keyword">await</span> promise<span class="token punctuation">;</span>\n</code></pre></div><p>关键字 <code>await</code> 让 JavaScript 引擎等待直到 promise 完成（settle）并返回结果。这个行为不会耗费任何 CPU 资源，因为 JavaScript 引擎可以同时处理其他任务：执行其他脚本，处理事件等。</p><h2 id="参考阅读" tabindex="-1">参考阅读 <a class="header-anchor" href="#参考阅读" aria-hidden="true">#</a></h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous" target="_blank" rel="noopener noreferrer">异步 JavaScript</a></li><li><a href="https://zh.javascript.info/async" target="_blank" rel="noopener noreferrer">JavaScript 编程语言 - Promise，async/await</a></li><li><a href="https://www.ruanyifeng.com/blog/2015/04/generator.html" target="_blank" rel="noopener noreferrer">《深入掌握 ECMAScript 6 异步编程》</a></li></ul>',76)];var c=n(e,[["render",function(n,t,p,e,c,u){return a(),s("div",null,o)}]]);export{p as __pageData,c as default};
